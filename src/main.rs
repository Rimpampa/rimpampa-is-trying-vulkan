use std::{convert, ffi};

use ash::vk;
use cstr::cstr;
use winit::window as win;

mod vku;

#[derive(Clone, Copy, Debug, thiserror::Error)]
enum AppError {
    /// An error directly returned by a Vulkan function
    #[error("Vulkan error: {0:?}")]
    Vku(#[from] vku::Error),

    #[error("There are no suitable physical devices")]
    NoSuitablePhyDev,
}

type AppResult<T> = Result<T, AppError>;

struct VulkanState<'a>(vku::LogicalDev<vku::Surface<'a, vku::DebugUtils<vku::Instance<'a>>>>);

impl<'a> VulkanState<'a> {
    fn create(entry: &'a ash::Entry, window: &'a win::Window) -> AppResult<Self> {
        let validation_layers = vec![
            cstr!(VK_LAYER_KHRONOS_validation).as_ptr(),
            // ...
        ];

        let mut extensions = vec![
            // ash::extensions::ext::DebugUtils::name()
            cstr!(VK_EXT_debug_utils).as_ptr(),
            // ash::extensions::khr::Surface::name()
            cstr!(VK_KHR_surface).as_ptr(),
            // ...
        ];

        extensions.extend(
            vku::surface::extensions(&window)
                .unwrap()
                .into_iter()
                .map(ffi::CStr::as_ptr),
        );

        let device_extensions = vec![
            // ash::extensions::khr::Swapchain::name()
            cstr!(VK_KHR_swapchain),
            // ...
        ];

        let instance = unsafe {
            vku::Instance::new(
                entry,
                &validation_layers,
                &extensions,
                cstr!("Vulkan Tutorial"),
            )?
        };

        let debug_utils = vku::DebugUtils::new(instance)?;

        let surface = vku::Surface::new(debug_utils, window)?;

        let phy_devs = vku::PhysicalDevList::list(surface)?;

        let (dev_idx, indices) = phy_devs
            .iter()
            .enumerate()
            .map(|(i, dev)| -> AppResult<_> {
                let indices = physical_device_suitability(dev, &device_extensions)?;
                Ok(Some(i).zip(indices))
            })
            .filter_map(Result::transpose)
            .find(Result::is_ok)
            .ok_or(AppError::NoSuitablePhyDev)
            .unwrap()?;

        let logic_dev = unsafe { phy_devs.select(dev_idx, indices.infos())? };

        Ok(Self(logic_dev))
    }
}

/// Checks if the physical device has the right properties for the application
///
/// # Return
///
/// The queues families indices of the needed queue families if all present
fn physical_device_suitability<I: vku::SurfaceHolder>(
    dev: vku::PhysicalDevRef<I>,
    dev_exts: &[&ffi::CStr],
) -> vku::Result<Option<QueueFamiliesIndices>> {
    let prop = dev.properties();
    let feat = dev.features();
    let exts: Vec<_> = dev
        .extension_properties()?
        .iter()
        // SAFETY
        //
        // This pointer was generated by the Vulkan driver
        .map(|prop| unsafe { ffi::CStr::from_ptr(prop.extension_name.as_ptr()) })
        .collect();

    let dev_types = {
        use vk::PhysicalDeviceType as devtype;
        [devtype::DISCRETE_GPU, devtype::INTEGRATED_GPU]
    };
    if feat.tessellation_shader == 0 || !dev_types.contains(&prop.device_type) {
        return Ok(None);
    }

    if !dev_exts.iter().all(|ext_name| exts.contains(ext_name)) {
        return Ok(None);
    }

    Ok(QueueFamiliesIndices::get(dev))
}

#[derive(Clone, Copy)]
struct QueueFamiliesIndices {
    graphics: u32,
    present: u32,
}

impl QueueFamiliesIndices {
    /// Returns the queue families indices needed by the application,
    /// or [None] if they are not supported
    fn get<I: vku::SurfaceHolder>(dev: vku::PhysicalDevRef<I>) -> Option<Self> {
        let queue_families = dev.queue_families();
        let graphics = queue_families
            .iter()
            .position(|fam| fam.queue_flags.contains(vk::QueueFlags::GRAPHICS))?
            as u32;
        let present = (0..queue_families.len())
            .find(|&fam| dev.supports_surface(fam as u32).unwrap_or(false))?
            as u32;
        Some(Self { graphics, present })
    }

    /// Returns the info needed for creating the queues
    fn infos(self) -> Vec<vku::QueueFamilyInfo<'static>> {
        let arr = [self.graphics, self.present];
        let mut vec = Vec::<vku::QueueFamilyInfo>::with_capacity(arr.len());
        arr.into_iter().for_each(|n| {
            if vec.iter().any(|i| i.index == n) {
                return;
            }
            vec.push(vku::QueueFamilyInfo {
                index: n,
                priorities: &[1.0],
            })
        });
        vec
    }
}

fn main() {
    let event_loop = winit::event_loop::EventLoop::new();
    let window = win::WindowBuilder::new()
        .with_title("Vulkan Test")
        .with_inner_size(winit::dpi::LogicalSize::new(200, 200))
        .build(&event_loop)
        .unwrap();

    let entry = unsafe { ash::Entry::load().unwrap() };

    let vk_state = VulkanState::create(&entry, &window);
}
